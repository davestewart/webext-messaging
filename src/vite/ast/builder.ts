import { Node, Project } from 'ts-morph'
import fs from 'fs'
import path from 'path'
import { glob } from 'glob'
import { extractRoutesFromObjectLiteral, resolveVariableToObjectLiteral } from './utils'
import type { MessageRouterPluginOptions } from '../index'
import type { RouteInfo } from './types'

interface RouterDefinition {
  group: string | null
  routes: RouteInfo[]
  file: string
  routesSource: string // the variable/expression text for debugging
}

interface BuilderState {
  // all routers found
  routers: RouterDefinition[]

  // flat map for global type generation
  allRoutes: Map<string, RouteInfo>

  // grouped for typed group senders
  routesByGroup: Map<string, Map<string, RouteInfo>>

  // track which files define routes and which use them
  routeDefinitions: Map<string, RouteInfo[]>
  routerCalls: Map<string, RouterDefinition[]>
  dependencies: Map<string, Set<string>> // file -> files that import from it
}

type WatchEvent = 'add' | 'change' | 'unlink'

export function useBuilder (options: Pick<MessageRouterPluginOptions, 'include' | 'declarationFile' | 'tsconfig' | 'moduleName'> = {}) {
  const {
    include = ['src/**/*.{ts,tsx}'],
    declarationFile = '.vite/message-router.d.ts',
    moduleName = 'vite-message-router',
    tsconfig = 'tsconfig.json',
  } = options

  const state: BuilderState = {
    routers: [],
    allRoutes: new Map(),
    routesByGroup: new Map(),
    routeDefinitions: new Map(),
    routerCalls: new Map(),
    dependencies: new Map(),
  }

  let root = ''
  let project: Project

  // -------------------------------------------------------------------------------------------------------------------
  // public
  // -------------------------------------------------------------------------------------------------------------------

  function init (projectRoot = '') {
    console.log('\n\nâš ï¸ Initializing builder...')
    root = projectRoot
    project = new Project({
      tsConfigFilePath: path.resolve(root, tsconfig),
      skipAddingFilesFromTsConfig: false, // keep files in project for resolution
    })
  }

  // -------------------------------------------------------------------------------------------------------------------
  // vite
  // -------------------------------------------------------------------------------------------------------------------

  function configureServer (server: any) {
    server.watcher
      .on('add', (file: string) => testFile(file, 'add'))
      .on('change', (file: string) => testFile(file, 'change'))
      .on('unlink', (file: string) => testFile(file, 'unlink'))
  }

  let invalidateFn: (() => void) | null = null

  function onInvalidate (fn: () => void) {
    invalidateFn = fn
  }

  // -------------------------------------------------------------------------------------------------------------------
  // files
  // -------------------------------------------------------------------------------------------------------------------

  function update (): string {
    scanAllFiles()
    return writeTypes()
  }

  function testFile (file: string, event: WatchEvent): string | void {
    if (file.endsWith('.ts') || file.endsWith('.js')) {
      const code = fs.readFileSync(file, 'utf-8')
      const isValidFile = /\b(defineMessageRoutes|createMessageRouter|createPortRouter)\b/.test(code)
      if (isValidFile) {
        processFile(file, event)
        writeTypes()
        if (invalidateFn) {
          invalidateFn()
        }
      }
    }
  }

  // -------------------------------------------------------------------------------------------------------------------
  // file generation
  // -------------------------------------------------------------------------------------------------------------------

  function writeTypes (): string {
    // generate global routes interface
    const allRouteEntries = Array.from(state.allRoutes.entries())
      .map(([path, info]) => `    '${path}': (${info.paramText}) => ${info.returnType}`)
      .join('\n')

    const output = `// Generated by webext-message-router

declare module '${moduleName}' {
  export type MessageRoutes = {
${allRouteEntries}
  }
  
  type Path = keyof MessageRoutes & string
  type Input<P extends Path> = Parameters<MessageRoutes[P]>[0]
  type Output<P extends Path> = ReturnType<MessageRoutes[P]>
  
  export const sender: MessageSender<MessageRoutes>
  
  export const createMessageSender: (options?: MessageSenderOptions) => MessageSender<MessageRoutes>
  export const createPostSender: (options?: PostMessageOptions) => MessageSender<MessageRoutes>
  
  export const sendMessage: <P extends Path>(
    path: P,
    ...payload: Input<P> extends undefined ? [] : [Input<P>]
  ) => Promise<Output<P> | undefined>
  
  export const sendPortMessage: PortSender<MessageRoutes>['sendMessage']

  // export const sendMessage: MessageSender<MessageRoutes>['sendMessage']
  // export const sendPortMessage: PortSender<MessageRoutes>['sendMessage']
  
  export const foo: {
    test(id: string): Promise<string>
  }
  
  export const bar: {
    test(): Promise<string>
  }
  
  const _default: {
    foo: {
      test(id: string): Promise<string>
    } 
    bar: {
      test(): Promise<string>
    }
  }

  export default _default
}
`
    // save
    if (declarationFile) {
      const outputPath = path.resolve(root, declarationFile)
      fs.mkdirSync(path.dirname(outputPath), { recursive: true })
      fs.writeFileSync(outputPath, output)
      // console.log(`\nâœ“ Generated ${outputPath}`)
    }

    // return
    return output
  }

  function getVirtualModuleContent (): string {
    return `// Generated by webext-message-router

import {
  createMessageSender,
  createMessageRouter,
  createPortRouter,
  createPortSender,
} from 'webext-message-router'

export {
  createMessageSender,
  createMessageRouter,
  createPortRouter,
  createPortSender,
}

export const sender = createMessageSender()
export const sendMessage = sender.sendMessage

export const foo = {
  async test (id) {
    return await sendMessage('foo/test', id)
  }
}

export const bar = {
  async test () {
    return sendMessage('bar/test')
  }
}

export default {
  test () {
    return 'default'
  }
} 
`
  }

  // -------------------------------------------------------------------------------------------------------------------
  // scaning and processing
  // -------------------------------------------------------------------------------------------------------------------

  function processFile (changedFile: string, event: WatchEvent) {
    console.log('Process file:', event,  changedFile)

    const filesToRescan = new Set([changedFile])

    // if this file defines routes, also rescan dependents
    if (state.routeDefinitions.has(changedFile)) {
      const dependents = state.dependencies.get(changedFile)
      dependents?.forEach(dep => filesToRescan.add(dep))
    }

    // refresh changed files in ts-morph project
    filesToRescan.forEach(file => {
      const sourceFile = project.getSourceFile(file)
      if (sourceFile) {
        sourceFile.refreshFromFileSystemSync()
      }
    })

    // invalidate affected files
    filesToRescan.forEach(file => {
      state.routeDefinitions.delete(file)
      state.routerCalls.delete(file)
    })

    // re-scan
    filesToRescan.forEach(file => {
      scanFileForRouteDefinitions(file)
    })
    filesToRescan.forEach(file => {
      scanFileForRouterCalls(file)
    })

    // rebuild
    buildFinalState()
  }

  function scanAllFiles () {
    console.log('Scanning files...')
    const files = glob.sync([...include, '!**/*.d.ts'], {
      cwd: root,
      absolute: true,
      ignore: ['**/node_modules/**', '**/dist/**', `**/${declarationFile}`],
    })

    console.log('Done scanning files:', files.length, 'files found.')
    clearState()

    // add all files to project first
    files.forEach(file => {
      try {
        project.addSourceFileAtPath(file)
      }
      catch (error) {
        console.warn(`Failed to add ${file}:`, error)
      }
    })

    // pass 1: find route definitions
    console.log('ðŸ“‹ Pass 1: Scanning for route definitions...')
    files.forEach(scanFileForRouteDefinitions)

    // pass 2: find router calls and resolve
    console.log('ðŸ” Pass 2: Scanning for router calls...')
    files.forEach(scanFileForRouterCalls)

    // build final state
    buildFinalState()
  }

  function scanFileForRouteDefinitions (filePath: string) {
    const sourceFile = project.getSourceFile(filePath)
    if (!sourceFile) return

    const fileRoutes: RouteInfo[] = []

    // look for defineMessageRoutes() calls
    sourceFile.forEachDescendant(node => {
      if (!Node.isCallExpression(node)) return

      const expression = node.getExpression()
      if (!Node.isIdentifier(expression)) return
      if (expression.getText() !== 'defineMessageRoutes') return

      const args = node.getArguments()
      if (args.length === 0) return

      const routesObject = resolveVariableToObjectLiteral(args[0], sourceFile)
      if (!routesObject) return

      const routes = extractRoutesFromObjectLiteral(routesObject, filePath)
      fileRoutes.push(...routes)
    })

    if (fileRoutes.length > 0) {
      state.routeDefinitions.set(filePath, fileRoutes)
      console.log(`  âœ“ Found ${fileRoutes.length} route definitions in ${path.basename(filePath)}`)
    }
  }

  function scanFileForRouterCalls (filePath: string) {
    const sourceFile = project.getSourceFile(filePath)
    if (!sourceFile) return

    const fileRouters: RouterDefinition[] = []

    sourceFile.forEachDescendant(node => {
      if (!Node.isCallExpression(node)) return

      const expression = node.getExpression()
      if (!Node.isIdentifier(expression)) return

      const funcName = expression.getText()
      const isRouterFactory = funcName === 'createMessageRouter' || funcName === 'createPortRouter'
      if (!isRouterFactory) return

      const args = node.getArguments()
      if (args.length === 0) return

      const [routesArg, optionsArg] = args

      // resolve routes
      const routes = resolveRoutesForRouter(routesArg, sourceFile, filePath)
      if (routes.length === 0) {
        console.warn(`  âš ï¸ Could not resolve routes for ${funcName} in ${path.basename(filePath)}`)
        return
      }

      // get group from options
      const group = extractGroupFromOptions(optionsArg)

      fileRouters.push({
        group,
        routes,
        file: filePath,
        routesSource: routesArg.getText(),
      })

      const groupLabel = group ? `group: ${group}` : 'no group'
      console.log(`  âœ“ Found ${funcName} with ${routes.length} routes (${groupLabel})`)
    })

    if (fileRouters.length > 0) {
      state.routerCalls.set(filePath, fileRouters)
    }
  }

  function resolveRoutesForRouter (routesArg: Node, sourceFile: any, currentFile: string): RouteInfo[] {
    // try to resolve to object literal
    const routesObject = resolveVariableToObjectLiteral(routesArg, sourceFile)

    if (routesObject) {
      return extractRoutesFromObjectLiteral(routesObject, currentFile)
    }

    // if it's an identifier, try to resolve via imports
    if (Node.isIdentifier(routesArg)) {
      const symbol = routesArg.getSymbol()
      const declarations = symbol?.getDeclarations() || []

      for (const declaration of declarations) {
        const declFile = declaration.getSourceFile()
        const declFilePath = declFile.getFilePath()

        // track dependency
        if (!state.dependencies.has(declFilePath)) {
          state.dependencies.set(declFilePath, new Set())
        }
        state.dependencies.get(declFilePath)!.add(currentFile)

        // check if we already scanned this file's definitions
        const cachedRoutes = state.routeDefinitions.get(declFilePath)
        if (cachedRoutes) {
          return cachedRoutes
        }

        // try to resolve from the declaration
        if (Node.isVariableDeclaration(declaration)) {
          const initializer = declaration.getInitializer()
          if (initializer) {
            const resolved = resolveVariableToObjectLiteral(initializer, declFile)
            if (resolved) {
              return extractRoutesFromObjectLiteral(resolved, declFilePath)
            }
          }
        }
      }
    }

    return []
  }

  function extractGroupFromOptions (optionsArg?: Node): string | null {
    if (!optionsArg || !Node.isObjectLiteralExpression(optionsArg)) {
      return null
    }

    const groupProp = optionsArg.getProperty('group')
    if (!groupProp || !Node.isPropertyAssignment(groupProp)) {
      return null
    }

    const initializer = groupProp.getInitializer()
    if (!initializer || !Node.isStringLiteral(initializer)) {
      return null
    }

    return initializer.getLiteralText()
  }

  function buildFinalState () {
    state.routers = []
    state.allRoutes.clear()
    state.routesByGroup.clear()

    // collect all routers
    for (const routers of state.routerCalls.values()) {
      state.routers.push(...routers)
    }

    // build flat map and grouped map
    state.routers.forEach(router => {
      router.routes.forEach(route => {
        // add to flat map
        state.allRoutes.set(route.path, route)

        // add to group map
        const group = router.group || 'default'
        if (!state.routesByGroup.has(group)) {
          state.routesByGroup.set(group, new Map())
        }
        state.routesByGroup.get(group)!.set(route.path, route)
      })
    })

    console.log(`\nðŸ“Š Summary:`)
    console.log(`  Total routes: ${state.allRoutes.size}`)
    console.log(`  Groups: ${state.routesByGroup.size}`)
    state.routesByGroup.forEach((routes, group) => {
      console.log(`    - ${group}: ${routes.size} routes`)
    })
  }

  function clearState () {
    state.routers = []
    state.allRoutes.clear()
    state.routesByGroup.clear()
    state.routeDefinitions.clear()
    state.routerCalls.clear()
    state.dependencies.clear()
  }

  return {
    init,
    update,
    testFile,
    configureServer,
    onInvalidate,
    getVirtualModuleContent,
  }
}
